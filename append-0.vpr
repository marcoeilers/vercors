domain WellFoundedOrder[T]  {
  
  function bounded(v: T): Bool 
  
  function decreasing(v1: T, v2: T): Bool 
}

domain IntOrder  {
  
  axiom {
    (forall i: Int ::0 <= i == (bounded(i): Bool))
  }
  
  axiom {
    (forall i: Int ::(forall j: Int ::i < j == (decreasing(i, j): Bool)))
  }
}

domain TNull  {
  
  function v_null(): TNull 
  
  axiom {
    (forall v: TNull ::v_null() == v)
  }
}

domain Void  {
  
  function unit(): Void 
  
  axiom {
    (forall v: Void ::true ==> unit() == v)
  }
}

field next: Ref

field val: Int

function contents1(this: Ref): Seq[Int]
  requires this != null
  requires acc(state(this), write)
  requires this != null
{
  (unfolding acc(state(this), write) in
    (this.next == null ?
      Seq(this.val) :
      Seq(this.val) ++ contents1(this.next)))
}

function type1(type2: Ref): Int
  decreases 
  ensures result >= 0
  ensures result <= 2
  ensures type2 == null ==> result == 0
  ensures type2 != null ==> result != 0


function subtype1(subtype2: Int, subtype3: Int): Bool
  requires subtype2 >= 0
  requires subtype2 <= 2
  requires subtype3 >= 0
  requires subtype3 <= 2
  decreases 
{
  (subtype2 == 0 ==> true) &&
  ((subtype2 == 2 ==> subtype3 == 2) &&
  (subtype2 == 1 ==> subtype3 == 1 || subtype3 == 2))
}

predicate state(this: Ref) {
  acc(this.val, 1 * write) && acc(this.next, 1 * write) &&
  (this.next != null ==> acc(state(this.next), write) && this.next != null)
}

predicate list(this: Ref, c: Seq[Int]) {
  acc(state(this), write) && this != null && contents1(this) == c
}

method contents(this: Ref)
  requires this != null
  requires acc(state(this), write)
  requires this != null
{
  assert false
}

method list1()
{
  assert false
}

method list2(tid: Int, v: Int) returns (this: Ref)
  ensures this != null
  ensures type1(this) == 1
  ensures acc(list(this, Seq(v)), write)
  ensures this != null
{
  {
    var exc: Ref
    var flatten: Ref
    var flatten1: Int
    var flatten2: Ref
    var flatten3: TNull
    var flatten4: Ref
    var flatten5: Ref
    var flatten6: TNull
    this := new(val, next)
    inhale type1(this) == 1
    exc := null
    flatten := this
    flatten1 := 0
    flatten.val := flatten1
    flatten2 := this
    flatten3 := v_null()
    flatten2.next := null
    flatten4 := this
    flatten4.val := v
    flatten5 := this
    flatten6 := v_null()
    flatten5.next := null
    fold acc(state(this), write)
    fold acc(list(this, Seq(v)), write)
    label BUBBLE
    assert exc == null
  }
}

method append_rec(this: Ref, l1: Seq[Int], l: Ref, l2: Seq[Int])
  requires this != null
  requires acc(list(this, l1), write)
  requires this != null
  requires l != null
  requires acc(list(l, l2), write)
  requires l != null
{
  assert false
}

method append_rec1(this: Ref, tid: Int, l: Ref, l1: Seq[Int], l2: Seq[Int])
  returns (res: Void)
  requires this != null
  requires acc(list(this, l1), write)
  requires this != null
  requires l != null
  requires acc(list(l, l2), write)
  requires l != null
  ensures acc(list(this, l1 ++ l2), write)
  ensures this != null
{
  {
    var exc: Ref
    var return: Void
    var tmp: Seq[Int]
    var flatten: Ref
    var flatten1: Seq[Int]
    var res1: Void
    exc := null
    unfold acc(list(this, l1), write)
    unfold acc(state(this), write)
    if (this.next == null) {
      flatten := this
      flatten.next := l
      unfold acc(list(this.next, l2), write)
    } else {
      flatten1 := contents1(this.next)
      tmp := flatten1
      fold acc(list(this.next, tmp), write)
      res1 := append_rec1(this.next, tid, l, tmp, l2)
      unfold acc(list(this.next, tmp ++ l2), write)
    }
    fold acc(state(this), write)
    fold acc(list(this, l1 ++ l2), write)
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method object()
{
  assert false
}

method object1(tid: Int) returns (this: Ref)
  ensures this != null
  ensures type1(this) == 2
{
  {
    var exc: Ref
    this := new()
    inhale type1(this) == 2
    exc := null
    label BUBBLE
    assert exc == null
  }
}

method type()
{
  assert false
}

method subtype(subtype2: Int, subtype3: Int)
  requires subtype2 >= 0
  requires subtype2 <= 2
  requires subtype3 >= 0
  requires subtype3 <= 2
{
  assert false
}